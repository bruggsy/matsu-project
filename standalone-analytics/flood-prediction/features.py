import numpy
from aster_api import png
def report(out, key, avgGradientMagnitude, avgGradient, curvature, poscurv, negcurv, flat, flatgradcut, curvatureMagnitude):
      # One could re-calculate this metadata after each basin is identified, but here we only do it once for the entire granule.
      # dump some summary info on the avg gradient magnitude
      nflat = flat.astype('int').sum()
      nnegcurv = negcurv.astype('int').sum()
      nposcurv = poscurv.astype('int').sum()
      nnonnegativeflat = (~negcurv & flat).astype('int').sum()
      nnegativeflat = (negcurv & flat).astype('int').sum()
      npositiveflat = (poscurv & flat).astype('int').sum()
      totpixels = flat.size
      out.write('.01 Percentile Avg Gradient Magnitude: %f\n'% numpy.percentile(avgGradientMagnitude,.01))
      out.write('.1 Percentile Avg Gradient Magnitude: %f\n'% numpy.percentile(avgGradientMagnitude,.1))
      out.write('1 Percentile Avg Gradient Magnitude: %f\n'% numpy.percentile(avgGradientMagnitude,1.))
      out.write('10 Percentile Avg Gradient Magnitude: %f\n'% numpy.percentile(avgGradientMagnitude,10.))
      out.write('90 Percentile Avg Gradient Magnitude: %f\n'% numpy.percentile(avgGradientMagnitude,90.))
      out.write('99 Percentile Avg Gradient Magnitude: %f\n'% numpy.percentile(avgGradientMagnitude,99.))
      out.write('100 Percentile Avg Gradient Magnitude: %f\n'% numpy.percentile(avgGradientMagnitude,100.))
      out.write('Minimum Avg Gradient Magnitude %f\n'%numpy.min(avgGradientMagnitude))
      out.write('Maximum Avg Gradient Magnitude %f\n'%numpy.max(avgGradientMagnitude))
      out.write('Median Avg Gradient Magnitude %f\n'% numpy.median(avgGradientMagnitude))
      out.write('Cut on Avg Gradient Defining Flat: %f \n'%flatgradcut)
      out.write('Total Pixels %i\n'%totpixels)
      out.write('Note that Flat, Negative, and Bowl classifications are not neccesarily mutually exclusive!\n')
      out.write('Number of Flat Pixels: %i ( %f %% ) \n'%(nflat, ( 100. * nflat )/totpixels))
      out.write('Hill-like pixels : %i ( %f %% ) \n'%(nnegcurv, ( 100. * nnegcurv )/totpixels))
      out.write('Bowl-like pixels : %i ( %f %% ) \n'%(nposcurv, ( 100. * nposcurv )/totpixels))
      out.write('Flat and not Hill-like pixels: %i ( %f %% ) \n'%(nnonnegativeflat, ( 100. * nnonnegativeflat )/totpixels))
      out.write('Flat and Hill-like pixels: %i ( %f %% ) \n'%(nnegativeflat, ( 100. * nnegativeflat )/totpixels))
      out.write('Flat and Bowl-like pixels: %i ( %f %% ) \n'%(npositiveflat, ( 100. * npositiveflat )/totpixels))
      out.write('Minimum Curvature %i \n'%numpy.where(numpy.bincount(curvatureMagnitude.flatten().astype('int')) != 0)[0][0])
      out.write('Maximum Curvature %i \n'%(len(numpy.bincount(curvatureMagnitude.flatten().astype('int'))) -1 ))
      out.write('Number of Curvature Values %i\n'%sum(numpy.bincount(curvatureMagnitude.flatten().astype('int')) != 0 ))
      out.write('Minimum Gradient %i\n'%numpy.where(numpy.bincount(avgGradientMagnitude.flatten().astype('int')) != 0)[0][0] )
      out.write('Maximum Gradient %i\n'%(len(numpy.bincount(avgGradientMagnitude.flatten().astype('int'))) -1 ))
      out.write('Number of Gradient Values %i\n'%sum(numpy.bincount(avgGradientMagnitude.flatten().astype('int')) !=0 ))
      # gradient:
      png(avgGradientMagnitude, fileName = key + 'gradient.png')
      png(avgGradient[0], fileName = key + 'AverageGradientLatitude.png')
      png(avgGradient[1], fileName = key + 'AverageGradientLongitude.png')
      png(avgGradient[0]/avgGradientMagnitude, fileName = key + 'AverageGradientDegSouth.png')
      png(avgGradient[1]/avgGradientMagnitude, fileName = key + 'AverageGradientDegEast.png')
      # curvature
      png(curvatureMagnitude, fileName = key + 'curvature.png') #, line=focus)
      png(numpy.max([curvature[0], curvature[1]], 0), fileName = key + 'MaxCurvature.png') 
      png(numpy.min([curvature[0], curvature[1]], 0), fileName = key + 'MinCurvature.png') 
      png(curvature[0], fileName = key + 'LatitudeCurvature.png')
      png(curvature[1], fileName = key + 'LongitudeCurvature.png')
      png(curvature[0]/numpy.sqrt(curvatureMagnitude), fileName = key + 'CurvatureDegSouth.png')
      png(curvature[1]/numpy.sqrt(curvatureMagnitude), fileName = key + 'CurvatureDegEast.png')
      # classifying regions
      png(flat.astype('float'), minRadiance=0, maxRadiance=1, fileName= key + 'flat.png')
      png((~negcurv & flat).astype('float'), fileName = key + 'FlatNotHill.png')
      png((negcurv & flat).astype('float'), fileName = key + 'FlatHill.png')
      png((poscurv & flat).astype('float'), fileName = key + 'FlatBowl.png')
